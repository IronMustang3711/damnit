// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


constexpr double pi = 3.14159265358979323846;

constexpr double wheel_diameter = 6.0;
constexpr int encoder_ticks_per_rev = 1410;

constexpr double distance_per_rev = wheel_diameter * pi; //18.8495

constexpr double encoder_ticks_per_inch = encoder_ticks_per_rev / distance_per_rev; //74.802823

//constexpr double max_fps = 4.0;

//constexpr double max_encoder_rate_per_sec = max_fps * 12.0 * encoder_ticks_per_inch;

constexpr double max_encoder_rate = 1100.0;//max_encoder_rate_per_sec / 10.0;


constexpr double FGain = 1023.0 / (max_encoder_rate - 0.1 * max_encoder_rate);


constexpr inline double inches_to_encoder_ticks(double inches) {
    return inches * encoder_ticks_per_inch;
}

#include <cmath>
#include <llvm/raw_ostream.h>
#include "Chassis.h"
#include "RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "Commands/DriveWithJoystick.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

constexpr int SLOT = 0;
constexpr int TIMEOUT = 10;

Chassis::Chassis() : frc::Subsystem("Chassis") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftFront = RobotMap::chassisLeftFront;
    leftRear = RobotMap::chassisLeftRear;
    leftSide = RobotMap::chassisLeftSide;
    rightFront = RobotMap::chassisRightFront;
    rightRear1 = RobotMap::chassisRightRear1;
    rightSide = RobotMap::chassisRightSide;
    differentialDrive = RobotMap::chassisDifferentialDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void Chassis::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    SetDefaultCommand(new DriveWithJoystick());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Chassis::Periodic() {
//    SmartDashboard::PutNumberArray("encoder position",
//    		llvm::ArrayRef<double>{(double)leftFront->GetSensorCollection().GetQuadraturePosition(),
//									(double)rightFront->GetSensorCollection().GetQuadraturePosition()});
//SmartDashboard::PutNumberArray("encoder positions",llvm::ArrayRef<double>({
//	static_cast<double>(leftFront->GetSelectedSensorPosition(0)),
//	static_cast<double>(rightFront->GetSelectedSensorPosition(0))
//}));
	//SmartDashboard::PutNumberArray("encoder positions", {double(leftFront->GetSelectedSensorPosition(0)});

    SmartDashboard::PutNumber("encoder position(left)", (double) leftFront->GetSelectedSensorPosition(0));
    SmartDashboard::PutNumber("encoder position(right)", (double) rightFront->GetSelectedSensorPosition(0));

//    SmartDashboard::PutNumberArray("encoder velocity",
//       		llvm::ArrayRef<double>{(double)leftFront->GetSensorCollection().GetQuadratureVelocity(),
//   									(double)rightFront->GetSensorCollection().GetQuadratureVelocity()});
    SmartDashboard::PutNumber("encoder velocity(left)", (double)leftFront->GetSelectedSensorVelocity(0));
    SmartDashboard::PutNumber("encoder velocity(right)", (double)rightFront->GetSelectedSensorVelocity(0));

    SmartDashboard::PutString("chassis command", GetCurrentCommand() == nullptr? "null" : GetCurrentCommand()->GetName());


    for (const auto t : {leftFront.get(), leftRear.get(), rightFront.get(), rightRear1.get()}) {
    	SmartDashboard::PutNumber("output "+ t->GetName(), t->GetMotorOutputPercent());
    }

    if(leftFront->GetControlMode() ==ControlMode::MotionMagic){
    for(const auto t : {leftFront.get(),rightFront.get()}){
    		SmartDashboard::PutNumber("closed loop error: "+t->GetName(), t->GetClosedLoopError(SLOT));
    		SmartDashboard::PutNumber("closed loop target: "+t->GetName(), t->GetClosedLoopTarget(SLOT));

    }
    }


}


// Put methods for controlling this subsystem
// here. Call these from Commands.

// add tank drive  %rod1
void Chassis::TankDrive(std::shared_ptr<Joystick> stickPosition) {
    double y = -stickPosition->GetY();
    double z = stickPosition->GetZ();

    // y and z cubed, results in less drive around zero input
    y = pow(y, 3);
    z = pow(z, 3);
    z = z * 0.6;

    differentialDrive->ArcadeDrive(y, z, false);
}

void Chassis::driveForward_mm(double distanceInches) {
    prepareForAutonomous();
    //configure closed loop settings
    for (const auto t : {leftFront.get(), leftRear.get(), rightFront.get(), rightRear1.get()}) {
        t->Config_kP(SLOT, 0.0, TIMEOUT);
        t->Config_kI(SLOT, 0.0, TIMEOUT);
        t->Config_kD(SLOT, 0.0, TIMEOUT);
        t->Config_kF(SLOT, FGain, TIMEOUT);

        constexpr double cruise_velocity = 0.2 * max_encoder_rate;
        constexpr double max_accel = 0.5 * cruise_velocity;

        t->ConfigMotionCruiseVelocity(static_cast<int>(cruise_velocity), TIMEOUT);
        t->ConfigMotionAcceleration(static_cast<int>(max_accel), TIMEOUT);

    }

    llvm::outs() << "about to move " << inches_to_encoder_ticks(distanceInches) << " ticks. \n";


    //not yet supported:
//    leftRear->ConfigRemoteFeedbackFilter(
//            leftFront->GetDeviceID(), RemoteSensorSource::RemoteSensorSource_TalonSRX_SelectedSensor, 0, TIMEOUT);
    leftRear->Follow(*leftFront);


//    rightRear1->ConfigRemoteFeedbackFilter(
//            rightFront->GetDeviceID(), RemoteSensorSource::RemoteSensorSource_TalonSRX_SelectedSensor, 0, TIMEOUT);
    rightRear1->Follow(*rightFront);

// ### START ###
    for (const auto t : {leftFront.get(), rightFront.get()}) {
        t->Set(ControlMode::MotionMagic, inches_to_encoder_ticks(distanceInches));
    }

}

void Chassis::resetEncoders() {
    for (const auto t : {leftFront.get(), rightFront.get()}) t->GetSensorCollection().SetQuadraturePosition(0, TIMEOUT);
}

void Chassis::prepareForAutonomous() {
    stop();
    for (const auto t : {leftFront.get(), leftRear.get(), rightFront.get(), rightRear1.get()}) {
        t->ConfigVoltageCompSaturation(11.0, TIMEOUT);
        t->EnableVoltageCompensation(true);
    }
    resetEncoders();
}

void Chassis::prepareForTeleop() {

    for (const auto t : {leftFront.get(), leftRear.get(), rightFront.get(), rightRear1.get()}) {
        t->EnableVoltageCompensation(false);
        t->SetNeutralMode(NeutralMode::Coast); // reduce the chances of tipping ( hopefully).
    }
}

bool Chassis::driveStraightIsOnTarget() {
	double leftErr = leftFront->GetClosedLoopError(SLOT);
	double rightErr = rightFront->GetClosedLoopError(SLOT);
	llvm::outs() << "err: left="<<leftErr<<" right="<<rightErr <<" \n";
    return leftErr < 1.0 && rightErr < 1.0;

}

void Chassis::stop() {
    enableInductiveBreaking(true);
    differentialDrive->StopMotor();
}

void Chassis::enableInductiveBreaking(bool enable) {
    for (const auto t : {leftFront.get(), leftRear.get(), rightFront.get(), rightRear1.get()}) {

        t->SetNeutralMode(enable ? NeutralMode::Brake : NeutralMode::Coast);
    }


}

void Chassis::ArcadeDrive(double fwd, double rotate) {
    differentialDrive->ArcadeDrive(fwd, rotate, false);

}

void Chassis::curvatureDrive(double fwd, double rotate, bool quickTurn) {
    differentialDrive->CurvatureDrive(fwd, rotate, quickTurn);
}

void Chassis::disableMotorSafety() {
	differentialDrive->SetSafetyEnabled(false);

	 for (const auto t : {leftFront.get(), leftRear.get(), rightFront.get(), rightRear1.get()}) {
		 t->SetSafetyEnabled(false);
	 }
	 differentialDrive->SetSafetyEnabled(false);
}

void Chassis::enableMotorSafety() {
	 for (const auto t : {leftFront.get(), leftRear.get(), rightFront.get(), rightRear1.get()}) {
		 t->SetSafetyEnabled(true);
	 }
		differentialDrive->SetSafetyEnabled(true);

}

void Chassis::mm_Periodic(double distanceInches) {
    for (const auto t : {leftFront.get(), rightFront.get()}) {
        t->Set(ControlMode::MotionMagic, inches_to_encoder_ticks(distanceInches));
    }
   leftRear->Set(ControlMode::Follower,leftFront->GetDeviceID());
   rightRear1->Set(ControlMode::Follower,rightFront->GetDeviceID());

}

void Chassis::testPeriodic() {
//	llvm::outs() << "left encoder: " << leftFront->GetSelectedSensorPosition(0)
//			<< " right encoder: "<<rightFront->GetSelectedSensorPosition(0) << "\n";
//	llvm::outs() << "lf " << leftFront->GetMotorOutputPercent()
//			<< "lr "<<leftRear->GetMotorOutputPercent()
//			<<"rf "<<rightFront->GetMotorOutputPercent()
//			<<"rr "<<rightRear1->GetMotorOutputPercent() <<"\n";
}
