// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


constexpr double pi = 3.14159265358979323846;

constexpr double wheel_diameter = 6.0;
constexpr int encoder_ticks_per_rev = 1410;

constexpr double distance_per_rev = wheel_diameter * pi;

constexpr double encoder_ticks_per_inch = encoder_ticks_per_rev / distance_per_rev;

constexpr double max_fps = 4.0;

constexpr double max_encoder_rate_per_sec = max_fps * 12.0 * encoder_ticks_per_inch;

constexpr double max_encoder_rate = max_encoder_rate_per_sec / 10.0;


constexpr double FGain = 1023.0 / (max_encoder_rate - 0.1 * max_encoder_rate);


constexpr inline double inches_to_encoder_ticks(double inches) {
    return inches * encoder_ticks_per_inch;
}

#include <cmath>
#include "Chassis.h"
#include "RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "Commands/DriveWithJoystick.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

constexpr int SLOT = 0;
constexpr int TIMEOUT = 10;

Chassis::Chassis() : frc::Subsystem("Chassis") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftFront = RobotMap::chassisLeftFront;
    leftRear = RobotMap::chassisLeftRear;
    leftSide = RobotMap::chassisLeftSide;
    rightFront = RobotMap::chassisRightFront;
    rightRear1 = RobotMap::chassisRightRear1;
    rightSide = RobotMap::chassisRightSide;
    differentialDrive = RobotMap::chassisDifferentialDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void Chassis::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    SetDefaultCommand(new DriveWithJoystick());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Chassis::Periodic() {
//    SmartDashboard::PutNumberArray("encoder position",
//    		llvm::ArrayRef<double>{(double)leftFront->GetSensorCollection().GetQuadraturePosition(),
//									(double)rightFront->GetSensorCollection().GetQuadraturePosition()});

    SmartDashboard::PutNumber("encoder position(left)",(double)leftFront->GetSensorCollection().GetQuadraturePosition());
    SmartDashboard::PutNumber("encoder position(right)",(double)rightFront->GetSensorCollection().GetQuadraturePosition());

//    SmartDashboard::PutNumberArray("encoder velocity",
//       		llvm::ArrayRef<double>{(double)leftFront->GetSensorCollection().GetQuadratureVelocity(),
//   									(double)rightFront->GetSensorCollection().GetQuadratureVelocity()});
    SmartDashboard::PutNumber("encoder velocity(left)", (double)leftFront->GetSensorCollection().GetQuadratureVelocity());
    SmartDashboard::PutNumber("encoder velocity(right)", (double)rightFront->GetSensorCollection().GetQuadratureVelocity());

}


// Put methods for controlling this subsystem
// here. Call these from Commands.

// add tank drive  %rod1
void Chassis::TankDrive(std::shared_ptr<Joystick> stickPosition) {
    double y = -stickPosition->GetY();
    double z = stickPosition->GetZ();

    // y and z cubed, results in less drive around zero input
    y = pow(y, 3);
    z = pow(z, 3);
    z = z * 0.6;

    differentialDrive->ArcadeDrive(y, z, false);
}

void Chassis::driveForward_mm(double distanceInches) {
    prepareForAutonomous();
    //configure closed loop settings
    for (const auto &t : {leftFront, leftRear, rightFront, rightRear1}) {
        t->Config_kP(SLOT, 5.0, TIMEOUT);
        t->Config_kI(SLOT, 0.0, TIMEOUT);
        t->Config_kD(SLOT, 300.0, TIMEOUT);
        t->Config_kF(SLOT, FGain, TIMEOUT);

        constexpr double cruise_velocity = 0.7 * max_encoder_rate;
        constexpr double max_accel = 0.5 * cruise_velocity;

        t->ConfigMotionCruiseVelocity(static_cast<int>(cruise_velocity), TIMEOUT);
        t->ConfigMotionAcceleration(static_cast<int>(max_accel), TIMEOUT);

    }

    //configure follower mode
    leftRear->ConfigRemoteFeedbackFilter(
            leftFront->GetDeviceID(), RemoteSensorSource::RemoteSensorSource_TalonSRX_SelectedSensor, 0, TIMEOUT);
    leftRear->Follow(*leftFront);


    rightRear1->ConfigRemoteFeedbackFilter(
            rightFront->GetDeviceID(), RemoteSensorSource::RemoteSensorSource_TalonSRX_SelectedSensor, 0, TIMEOUT);
    rightRear1->Follow(*rightFront);

// ### START ###
    for (const auto &t : {leftFront, leftRear, rightFront, rightRear1}) {
        t->Set(ControlMode::MotionMagic, inches_to_encoder_ticks(distanceInches));
    }

}

void Chassis::ResetEncoders() {
    for (const auto &t : {leftFront, rightFront}) t->GetSensorCollection().SetQuadraturePosition(0, TIMEOUT);
}

void Chassis::prepareForAutonomous() {
    stop();
    for (const auto &t : {leftFront, leftRear, rightFront, rightRear1}) {
        t->ConfigVoltageCompSaturation(11.0, TIMEOUT);
        t->EnableVoltageCompensation(true);
    }
    ResetEncoders();
}

void Chassis::prepareForTeleop() {

    for (const auto &t : {leftFront, leftRear, rightFront, rightRear1}) {
        t->EnableVoltageCompensation(false);
    }
}

bool Chassis::driveStraightIsOnTarget() {
    return leftFront->GetClosedLoopError(SLOT)
           + rightFront->GetClosedLoopError(SLOT)
           < 10;
}

void Chassis::stop() {
    enableInductiveBreaking(true);
    differentialDrive->StopMotor();
}

void Chassis::enableInductiveBreaking(bool enable) {
    for (const auto &t : {leftFront, leftRear, rightFront, rightRear1}) {

        t->SetNeutralMode(enable ? NeutralMode::Brake : NeutralMode::Coast);
    }


}

void Chassis::ArcadeDrive(double fwd, double rotate) {
    differentialDrive->ArcadeDrive(fwd, rotate, false);

}

void Chassis::curvatureDrive(double fwd, double rotate, bool quickTurn) {
    differentialDrive->CurvatureDrive(fwd, rotate, quickTurn);
}


